package main

import (
	"fmt"
	"github.com/microcosm-cc/bluemonday"
	"gopkg.in/russross/blackfriday.v1"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/jmervine/getdown/cli"
	. "github.com/jmervine/getdown/template"

	// using text so as not to auto escape html generated by blackfriday
	"text/template"
)

var Config = cli.Parse(os.Args)
var Valid = []string{".md", ".mdown"}

type MDown struct {
	Title    string
	Path     string
	Style    string
	Markdown []byte
	Body     string
	Files    map[string][]string
	Template *template.Template
}

func NewMDown(p string) MDown {
	if path.Ext(p) == "" {
		p = path.Join(p, Config.Index)
	}

	d := &MDown{
		Path:  path.Join(Config.Basedir, p),
		Style: Config.Style,
	}

	if Config.Title == "" {
		d.Title = path.Base(Config.Basedir)
	} else {
		d.Title = Config.Title
	}

	if !d.IsValid() {
		return *d
	}

	mdown, e := ioutil.ReadFile(d.Path)
	if e != nil {
		panic(e)
	}

	d.Markdown = mdown

	unsafe := blackfriday.MarkdownCommon(mdown)
	d.Body = string(bluemonday.UGCPolicy().SanitizeBytes(unsafe))

	d.Files = make(map[string][]string)
	filepath.Walk(Config.Basedir, func(p string, f os.FileInfo, err error) error {
		if IsMarkdown(p) {
			p = strings.TrimPrefix(p, Config.Basedir)
			dir, name := path.Split(p)
			d.Files[dir] = append(d.Files[dir], name)
		}
		return nil
	})

	return *d
}

func IsMarkdown(p string) bool {
	for _, ext := range Valid {
		if path.Ext(p) == ext {
			return true
		}
	}
	return false
}

func (d MDown) IsValid() bool {
	return IsMarkdown(d.Path)
}

func (d MDown) Render(w http.ResponseWriter) {
	var t *template.Template
	var e error

	t, e = template.New(d.Path).Parse(Template)

	if e != nil {
		panic(e)
	}

	w.Header().Set("Content-Type", "text/html")
	t.ExecuteTemplate(w, d.Path, d)
}

func main() {
	if Config.Addr == "" { // will be empty on "help" or "version"
		os.Exit(0)
	}

	handler := func(w http.ResponseWriter, r *http.Request) {
		begin := time.Now()
		md := NewMDown(r.URL.Path)
		if md.IsValid() {
			md.Render(w)
			log.Printf("event=request method=%s status=%d source=%s url=%s duration=%s\n",
				r.Method, 200, md.Path, r.URL.Path, fmt.Sprintf("%s", time.Since(begin)),
			)
		} else {
			http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				http.FileServer(http.Dir(Config.Basedir)).ServeHTTP(w, r)
				log.Printf("event=static method=%s url=%s duration=%s\n",
					r.Method, r.URL.Path, fmt.Sprintf("%s", time.Since(begin)),
				)
			}).ServeHTTP(w, r)
		}
	}

	s := &http.Server{
		Addr:    Config.Listener(),
		Handler: http.HandlerFunc(handler),
	}

	log.Printf("event=startup config=%#v\n", Config)
	log.Fatal(s.ListenAndServe())
}
